<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation of SubmodularUtilities.jl · SubmodularUtilities.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SubmodularUtilities.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Documentation of SubmodularUtilities.jl</a><ul class="internal"><li><a class="toctext" href="#Maximization-1">Maximization</a></li><li><a class="toctext" href="#Rounding-1">Rounding</a></li><li><a class="toctext" href="#Multilinear-Extension-1">Multilinear Extension</a></li><li><a class="toctext" href="#Submodular-Functions-1">Submodular Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Documentation of SubmodularUtilities.jl</a></li></ul><a class="edit-page" href="https://github.com/lchen91/Submodular_Utilities/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Documentation of SubmodularUtilities.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Documentation-of-SubmodularUtilities.jl-1" href="#Documentation-of-SubmodularUtilities.jl-1">Documentation of SubmodularUtilities.jl</a></h1><h2><a class="nav-anchor" id="Maximization-1" href="#Maximization-1">Maximization</a></h2><p>This subset contains functions related to submodular maximization.</p><h3><a class="nav-anchor" id="Lazy-Greedy-1" href="#Lazy-Greedy-1">Lazy Greedy</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.lazy_greedy-Tuple{Any,Any,Any}" href="#SubmodularUtilities.lazy_greedy-Tuple{Any,Any,Any}"><code>SubmodularUtilities.lazy_greedy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lazy_greedy(f, ground_set, k)</code></pre><p><code>ground_set</code> should be an array of unique integers, which denotes the ground  set of monotone submodular function <code>f</code>. <code>f</code> represents a monotone submodular  function. If <code>T</code> is an array whose elements constitute a subset of <code>ground_set</code>,  <code>f(T)</code> is the function value of <code>T</code>. <code>k</code> is the cardinality constraint.  <code>lazy_greedy</code> outputs an array of length <code>k</code> using the lazy greedy algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L10-L18">source</a></section><h3><a class="nav-anchor" id="Constraint-1" href="#Constraint-1">Constraint</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.Constraint" href="#SubmodularUtilities.Constraint"><code>SubmodularUtilities.Constraint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Constraint</code></pre><p>The constraints are A*x sense b and lb &lt;= x &lt;= ub.  <code>sense</code> is a vector of constraint sense characters <code>&lt;</code>, <code>=</code>, and <code>&gt;</code>. <code>A</code> is a 2-dimensional array, which denotes the constraint matrix. <code>b</code> is the right-hand side vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L49-L56">source</a></section><h3><a class="nav-anchor" id="Meta-Frank-Wolfe-with-Variance-Reduction-1" href="#Meta-Frank-Wolfe-with-Variance-Reduction-1">Meta-Frank-Wolfe with Variance Reduction</a></h3><p>The Meta-Frank-Wolfe algorithm solves the online maximization problem of monotone continuous DR-submodular functions. The vanilla Meta-Frank-Wolfe algorithm is proposed in <a href="#footnote-CHK">[CHK]</a> and works when accurate gradient is available. The verison with variance reduction is proposed in <a href="#footnote-CHHK">[CHHK]</a> and solves the problem when only an unbiased estimate of gradient is available.</p><div class="footnote" id="footnote-CHK"><a href="#footnote-CHK"><strong>[CHK]</strong></a><p>Lin Chen, Hamed Hassani, and Amin Karbasi, “Online Continuous Submodular Maximization”, in Proc. of AISTATS 2018.</p></div><div class="footnote" id="footnote-CHHK"><a href="#footnote-CHHK"><strong>[CHHK]</strong></a><p>Lin Chen, Christopher Harshaw, Hamed Hassani, and Amin Karbasi, “Projection-Free Online Optimization with Stochastic Gradient: From Convexity to Submodularity“, in Proc. of ICML 2018.</p></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.meta_frank_wolfe-NTuple{6,Any}" href="#SubmodularUtilities.meta_frank_wolfe-NTuple{6,Any}"><code>SubmodularUtilities.meta_frank_wolfe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">meta_frank_wolfe(dim_x, f_list, g_list, eta, K, constraint; variance_reduction = false, n0 = rand(dim_x))</code></pre><p>Args:</p><ul><li><code>dim_x</code>: The dimension of the variables that we optimize.</li><li><code>f_list</code>: List of continuous DR-submodular functions <code>[f_1, f_2, ..., f_T]</code>.</li><li><code>g_list</code>: List of (unbiased estimates of) the gradients of functions in <code>f_list</code>.</li><li><code>eta</code>: This implementation uses Follow-Perturbed-Leader (FPL) for linear losses (which can be found in Hazan&#39;s book Introduction to Online Convex Optimization) as the online linear maximization algorithm. <code>eta</code> is the parameter of FPL.</li><li><code>K</code>: Number of instances of the chosen online linear maximization algorithm.</li><li><code>constraint</code>: Constraint set. It is an object of type <code>Constraint</code>.</li><li><code>variance_reduction</code>: Boolean variable which is <code>true</code> if variance reduction is enabled</li><li><code>n0</code>: the value of n0 in FPL for linear losses.</li></ul><p>Returns:</p><ul><li>Array of rewards <code>[f_1(x_1), f_2(x_2), ..., f_T(f_T)]</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L82-L97">source</a></section><h3><a class="nav-anchor" id="Projection-Operator-1" href="#Projection-Operator-1">Projection Operator</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.get_projection_operator-Tuple{Any}" href="#SubmodularUtilities.get_projection_operator-Tuple{Any}"><code>SubmodularUtilities.get_projection_operator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">get_projection_operator(constraint; dim_x = size(constraint.A)[2])</code></pre><p>Args:</p><ul><li><code>constraint</code>: Constraint set. It is an object of type <code>Constraint</code>.</li><li><code>dim_x</code>: the dimension of the point. The default value is deduced from the size of <code>constraint.A</code>.</li></ul><p>Returns: A function <code>projection</code> such that <code>projection(x)</code> outputs the projection of <code>x</code> onto the set <code>constraint</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L134-L144">source</a></section><h3><a class="nav-anchor" id="Online-Gradient-Ascent-1" href="#Online-Gradient-Ascent-1">Online Gradient Ascent</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.online_gradient_ascent-NTuple{4,Any}" href="#SubmodularUtilities.online_gradient_ascent-NTuple{4,Any}"><code>SubmodularUtilities.online_gradient_ascent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">online_gradient_ascent(x0, f_list, g_list, projection; step_size = t-&gt;1/t)</code></pre><p>Args: </p><ul><li><code>x0</code>: the initial value</li><li><code>f_list</code>: List of continuous DR-submodular functions <code>[f_1, f_2, ..., f_T]</code>.</li><li><code>g_list</code>: List of (unbiased estimates of) the gradients of functions in <code>f_list</code>.</li><li><code>projection</code>: Projection operator of the constraint set. You may want to get it by calling <code>get_projection_operator</code>.</li><li><code>step_size</code>: A function such that <code>step_size(t)</code> is the step size at the t-th iteration.</li></ul><p>Returns:</p><ul><li>Array of rewards <code>[f_1(x_1), f_2(x_2), ..., f_T(f_T)]</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L157-L169">source</a></section><h2><a class="nav-anchor" id="Rounding-1" href="#Rounding-1">Rounding</a></h2><p>This subset contains functions related to rounding a fractional vector between 0 and 1 into a binary vector (equivalently, a discrete set).</p><h3><a class="nav-anchor" id="Pipage-Rounding-1" href="#Pipage-Rounding-1">Pipage Rounding</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.pipage_round-Tuple{Any}" href="#SubmodularUtilities.pipage_round-Tuple{Any}"><code>SubmodularUtilities.pipage_round</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pipage_round(x)</code></pre><p>Given an array <code>x</code> whose every entry is between 0 and 1, round x into a binary vector using the pipage rounding algorithm presented in <a href="#footnote-ccpv">[ccpv]</a>.</p><div class="footnote" id="footnote-ccpv"><a href="#footnote-ccpv"><strong>[ccpv]</strong></a><p>Calinescu, Gruia, et al. &quot;Maximizing a monotone submodular function subject to a matroid constraint.&quot; SIAM Journal on Computing 40.6 (2011): 1740-1766.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L183-L190">source</a></section><h3><a class="nav-anchor" id="Random-Rounding-1" href="#Random-Rounding-1">Random Rounding</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.random_round-Tuple{Any}" href="#SubmodularUtilities.random_round-Tuple{Any}"><code>SubmodularUtilities.random_round</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">random_round(x)</code></pre><p>Given an array <code>x</code> whose every entry is between 0 and 1, round <code>x</code> into a binary vector.  The i-th entry of the output vector is 1 with probability <code>x[i]</code> and is 0 otherwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L250-L255">source</a></section><h2><a class="nav-anchor" id="Multilinear-Extension-1" href="#Multilinear-Extension-1">Multilinear Extension</a></h2><p>This subset contains functions related to multilinear extension of submodular set functions.</p><h3><a class="nav-anchor" id="Random-Evaluation-of-Multilinear-Extension-1" href="#Random-Evaluation-of-Multilinear-Extension-1">Random Evaluation of Multilinear Extension</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.get_random_evaluation_of_multilinear_extension" href="#SubmodularUtilities.get_random_evaluation_of_multilinear_extension"><code>SubmodularUtilities.get_random_evaluation_of_multilinear_extension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_random_evaluation_of_multilinear_extension(f_discrete)</code></pre><p>The input <code>f_discrete</code> is assumed to be a monotone submodular function defined  on the ground set <code>1:n</code>, where n is some positive integer. Given an array <code>T</code>  whose elements are chosen from <code>1:n</code>, <code>f_discrete(T)</code> is the function value of  the subset <code>T</code>. <code>get_random_evaluation_of_multilinear_extension</code> returns a  function that takes a size-n array <code>x</code> as input and outputs an unbiased estimate of  the function value of the multilinear extension of <code>f_discrete</code> at <code>x</code>. In other  words, the output is a function that maps <code>x</code> to <code>f_discrete(random_round(x))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L262-L272">source</a></section><h3><a class="nav-anchor" id="Random-Gradient-of-Multilinear-Extension-1" href="#Random-Gradient-of-Multilinear-Extension-1">Random Gradient of Multilinear Extension</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.get_random_gradient_of_multilinear_extension" href="#SubmodularUtilities.get_random_gradient_of_multilinear_extension"><code>SubmodularUtilities.get_random_gradient_of_multilinear_extension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_random_gradient_of_multilinear_extension(f_discrete)</code></pre><p>The input <code>f_discrete</code> is assumed to be a monotone submodular function defined  on the ground set <code>1:n</code>, where n is some positive integer. Given an array <code>T</code>  whose elements are chosen from <code>1:n</code>, <code>f_discrete(T)</code> is the function value of  the subset <code>T</code>. <code>get_random_gradient_of_multilinear_extension</code> returns a  function that takes a size-n array <code>x</code> as input and outputs an unbiased estimate of  the gradient of the multilinear extension of <code>f_discrete</code> at <code>x</code>. </p><p>In other words, the output function first computes <code>S = random_round(x)</code>. Then  the i-th partial derivative is  <code>f_discrete(vcat(S, i)) - f_discrete(setdiff(S, i))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L278-L291">source</a></section><h2><a class="nav-anchor" id="Submodular-Functions-1" href="#Submodular-Functions-1">Submodular Functions</a></h2><p>This subset contains several examples of submodular functions. Given input data, the functions named <code>get_function_...</code> below return a submodular function. </p><h3><a class="nav-anchor" id="Exemplar-Based-Clustering-1" href="#Exemplar-Based-Clustering-1">Exemplar-Based Clustering</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.get_function_exemplar_based_clustering" href="#SubmodularUtilities.get_function_exemplar_based_clustering"><code>SubmodularUtilities.get_function_exemplar_based_clustering</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_function_exemplar_based_clustering(data)</code></pre><p>Returns the objective function of exemplar-based clustering defined on the  ground set <code>1:size(data)[1]</code>. The argument <code>data</code> is a 2-dimensional array.  Each row represents a data point and each column represents an attribute. </p></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L305-L311">source</a></section><h3><a class="nav-anchor" id="Active-Set-Selection-1" href="#Active-Set-Selection-1">Active Set Selection</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SubmodularUtilities.get_function_active_set_selection" href="#SubmodularUtilities.get_function_active_set_selection"><code>SubmodularUtilities.get_function_active_set_selection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_function_active_set_selection(data; sigma = 1., h = 0.75)</code></pre><p>Returns the objective function of active set selection defined on the ground set <code>1:size(data)[2]</code>. The argument <code>data</code> is a 2-dimensional array.  Each row represents a data point and each column represents an attribute.  The covariance matrix uses a Gaussian kernel  <code>exp(-norm(data[:, i] - data[:, j])^2 / h^2)</code>. The function value of the  objective function evaluated at the subset <code>S</code> is  <code>0.5 * log(det(eye(length(S)) + cov_matrix[S, S] / sigma^2))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/lchen91/Submodular_Utilities/blob/77d5850c0e317225e4cf3780d16f084cf7ae62df/src/SubmodularUtilities.jl#L325-L335">source</a></section><footer><hr/></footer></article></body></html>
